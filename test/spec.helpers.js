// Generated by CoffeeScript 1.3.3
(function() {
  var hasValue, justValues, lastNonError, seqs, timeUnitMillisecs, toValue, toValues, verifyCleanup, verifyExhausted, verifyFinalState, verifySingleSubscriber, verifySwitching;

  timeUnitMillisecs = 10;

  this.t = function(time) {
    return time * timeUnitMillisecs;
  };

  seqs = [];

  this.error = function(msg) {
    return new Bacon.Error(msg);
  };

  this.soon = function(f) {
    return setTimeout(f, t(1));
  };

  this.series = function(interval, values) {
    return Bacon.sequentially(t(interval), values);
  };

  this.repeat = function(interval, values) {
    var source;
    source = Bacon.repeatedly(t(interval), values);
    seqs.push({
      values: values,
      source: source
    });
    return source;
  };

  this.expectStreamEvents = function(src, expectedEvents) {
    runs(function() {
      return verifySingleSubscriber(src(), expectedEvents);
    });
    return runs(function() {
      return verifySwitching(src(), expectedEvents);
    });
  };

  this.expectPropertyEvents = function(src, expectedEvents) {
    var ended, events, events2, property, streamEnded;
    expect(expectedEvents.length > 0).toEqual(true);
    events = [];
    events2 = [];
    ended = false;
    streamEnded = function() {
      return ended;
    };
    property = src();
    expect(property instanceof Bacon.Property).toEqual(true);
    runs(function() {
      return property.subscribe(function(event) {
        if (event.isEnd()) {
          return ended = true;
        } else {
          events.push(toValue(event));
          if (event.hasValue()) {
            return property.subscribe(function(event) {
              if (event.isInitial()) {
                events2.push(event.value);
              }
              return Bacon.noMore;
            });
          }
        }
      });
    });
    waitsFor(streamEnded, t(50));
    return runs(function() {
      expect(events).toEqual(toValues(expectedEvents));
      expect(events2).toEqual(justValues(expectedEvents));
      verifyFinalState(property, lastNonError(expectedEvents));
      return verifyCleanup();
    });
  };

  verifySingleSubscriber = function(src, expectedEvents) {
    var ended, events, streamEnded;
    expect(src instanceof Bacon.EventStream).toEqual(true);
    events = [];
    ended = false;
    streamEnded = function() {
      return ended;
    };
    runs(function() {
      return src.subscribe(function(event) {
        if (event.isEnd()) {
          return ended = true;
        } else {
          return events.push(toValue(event));
        }
      });
    });
    waitsFor(streamEnded, t(50));
    return runs(function() {
      expect(events).toEqual(toValues(expectedEvents));
      verifyExhausted(src);
      return verifyCleanup();
    });
  };

  verifySwitching = function(src, expectedEvents) {
    var ended, events, newSink, streamEnded;
    events = [];
    ended = false;
    streamEnded = function() {
      return ended;
    };
    newSink = function() {
      return function(event) {
        if (event.isEnd()) {
          return ended = true;
        } else {
          events.push(toValue(event));
          src.subscribe(newSink());
          return Bacon.noMore;
        }
      };
    };
    runs(function() {
      return src.subscribe(newSink());
    });
    waitsFor(streamEnded, t(50));
    return runs(function() {
      expect(events).toEqual(toValues(expectedEvents));
      verifyExhausted(src);
      return verifyCleanup();
    });
  };

  verifyExhausted = function(src) {
    var events;
    events = [];
    src.subscribe(function(event) {
      return events.push(event);
    });
    return expect(events[0].isEnd()).toEqual(true);
  };

  lastNonError = function(events) {
    return _.last(_.filter(events, (function(e) {
      return toValue(e) !== "<error>";
    })));
  };

  verifyFinalState = function(property, value) {
    var events;
    events = [];
    property.subscribe(function(event) {
      return events.push(event);
    });
    return expect(toValues(events)).toEqual(toValues([value, "<end>"]));
  };

  verifyCleanup = this.verifyCleanup = function() {
    var seq, _i, _len;
    for (_i = 0, _len = seqs.length; _i < _len; _i++) {
      seq = seqs[_i];
      expect(seq.source.hasSubscribers()).toEqual(false);
    }
    return seqs = [];
  };

  toValues = function(xs) {
    var values, x, _i, _len;
    values = [];
    for (_i = 0, _len = xs.length; _i < _len; _i++) {
      x = xs[_i];
      values.push(toValue(x));
    }
    return values;
  };

  toValue = function(x) {
    if ((x != null) && (x.isEvent != null)) {
      if (x.isError()) {
        return "<error>";
      } else if (x.isEnd()) {
        return "<end>";
      } else {
        return x.value;
      }
    } else {
      return x;
    }
  };

  hasValue = function(x) {
    return toValue(x) !== "<error>";
  };

  justValues = function(xs) {
    return _.filter(xs, hasValue);
  };

}).call(this);
