// Generated by CoffeeScript 1.3.3
(function() {
  var Eggs, Model, ReplayBus, escapeRegExp, namedParam, optionalParam, routeStripper, splatParam,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Eggs = this.Eggs = {};

  Eggs.Model = Model = (function() {

    Model.prototype.idAttribute = 'id';

    function Model(attributes, options) {
      var attributeNamesBus, attributeNamesProperty, attrs, attrsInitialValidationError, defaults, setAttributesBus, validAttributesBus, validAttributesProperty, validSingleAttributes,
        _this = this;
      options = _.defaults({}, options, {
        shouldValidate: true
      });
      attrs = attributes || {};
      if (defaults = _.result(this, 'defaults')) {
        attrs = _.defaults({}, attrs, defaults);
      }
      attrsInitialValidationError = options.shouldValidate && (typeof this.validate === "function" ? this.validate(_.clone(attrs)) : void 0);
      validAttributesBus = new Bacon.Bus;
      if (!attrsInitialValidationError) {
        validAttributesProperty = validAttributesBus.toProperty(_.clone(attrs));
      } else {
        validAttributesProperty = validAttributesBus.toProperty();
      }
      validSingleAttributes = {};
      validAttributesProperty.onValue(function() {});
      setAttributesBus = new Bacon.Bus;
      attributeNamesBus = new Bacon.Bus;
      if (!attrsInitialValidationError) {
        attributeNamesProperty = attributeNamesBus.toProperty(_.keys(attrs));
      } else {
        attributeNamesProperty = attributeNamesBus.toProperty();
      }
      setAttributesBus.map(function(value) {
        return _.defaults({}, value, attrs);
      }).onValue(function(attrObject) {
        var error;
        if (_.isEqual(attrObject, attrs)) {
          return;
        }
        if (options.shouldValidate && (error = typeof _this.validate === "function" ? _this.validate(attrObject) : void 0)) {
          return validAttributesBus.error({
            error: error,
            attributes: attrObject
          });
        } else {
          attrsInitialValidationError = null;
          if (_.difference(_.keys(attrObject), _.keys(attrs)).length) {
            attributeNamesBus.push(_.keys(attrObject));
          }
          return validAttributesBus.push(_.clone(attrs = attrObject));
        }
      });
      this.attributes = function(name, value) {
        var newAttrs, setObject;
        if (arguments.length === 0) {
          return validAttributesProperty;
        }
        if (arguments.length === 1) {
          if (_.isObject(name)) {
            setAttributesBus.push(name);
            return validAttributesProperty;
          } else if (_.has(attrs, name)) {
            if (!validAttributesProperty[name]) {
              if (!attrsInitialValidationError) {
                validAttributesProperty[name] = validAttributesBus.map("." + name).toProperty(attrs[name]);
              } else {
                validAttributesProperty[name] = validAttributesBus.map("." + name).toProperty();
              }
            }
            return validAttributesProperty[name];
          } else {
            throw "Invalid attributes accessor: " + name;
          }
        } else {
          if (_.isArray(name)) {
            if (value['unset']) {
              newAttrs = _.omit(attrs, name);
              if (_.difference(_.keys(attrs), _.keys(newAttrs))) {
                attrs = newAttrs;
                attributeNamesBus.push(_.keys(attrs));
                validAttributesBus.push(_.clone(attrs));
              }
              return validAttributesProperty;
            }
          } else if (_.has(attrs, name)) {
            setObject = {};
            setObject[name] = value;
            setAttributesBus.push(setObject);
            return validAttributesProperty;
          } else {
            throw "Invalid attributes update: " + name + ", " + value;
          }
        }
      };
      this.attributeNames = function() {
        return attributeNamesProperty;
      };
      this.initialize.apply(this, arguments);
    }

    Model.prototype.initialize = function() {};

    Model.prototype.id = function() {
      var _this = this;
      return this._id || (this._id = this.attributes().map(function(attr) {
        return attr[_this.idAttribute];
      }));
    };

    Model.prototype.url = function() {
      var _this = this;
      return this._url || (this._url = this.id().map(function(id) {
        var base;
        base = _.result(_this, 'urlRoot') || (function() {
          throw new Error("Expecting `urlRoot` to be defined");
        })();
        if (base.charAt(base.length - 1) === '/') {
          base = base.substring(0, base.length - 1);
        }
        if (id) {
          return "" + base + "/" + (encodeURIComponent(id));
        }
        return base;
      }));
    };

    Model.prototype.fetch = function() {
      var _this = this;
      return this.url().take(1).flatMap(function(url) {
        return Bacon.fromPromise($.ajax({
          type: 'GET',
          dataType: 'json',
          url: url
        }));
      }).flatMap(function(result) {
        return _this.attributes(result);
      });
    };

    Model.prototype.save = function() {
      var _this = this;
      return Bacon.combineAsArray(this.url(), this.attributes()).take(1).flatMap(function(info) {
        var attributes, url;
        url = info[0], attributes = info[1];
        return Bacon.fromPromise($.ajax({
          type: attributes[_this.idAttribute] ? 'PUT' : 'POST',
          dataType: 'json',
          processData: false,
          url: url,
          data: attributes
        }));
      }).flatMap(function(result) {
        return _this.attributes(result);
      });
    };

    return Model;

  })();

  Eggs.model = function(extension) {
    var Surrogate, child, parent;
    parent = Model;
    if (extension && _.has(extension, 'constructor')) {
      child = extension.constructor;
    } else {
      child = function() {
        return parent.apply(this, arguments);
      };
    }
    Surrogate = (function() {

      function Surrogate() {
        this.constructor = child;
      }

      return Surrogate;

    })();
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;
    if (extension) {
      _.extend(child.prototype, extension);
    }
    child.__super__ = parent.prototype;
    return child;
  };

  Eggs.ReplayBus = ReplayBus = (function(_super) {

    __extends(ReplayBus, _super);

    function ReplayBus(replayCount) {
      var dispatcher, ended, guardedSink, inputs, sink, subscribeAll, subscribeThis, unsubAll, unsubFuncs,
        _this = this;
      this.replayCount = replayCount;
      sink = void 0;
      unsubFuncs = [];
      inputs = [];
      ended = false;
      guardedSink = function(input) {
        return function(event) {
          if (event.isEnd()) {
            remove(input, inputs);
            return Bacon.noMore;
          } else {
            return sink(event);
          }
        };
      };
      unsubAll = function() {
        var f, _i, _len;
        for (_i = 0, _len = unsubFuncs.length; _i < _len; _i++) {
          f = unsubFuncs[_i];
          f();
        }
        return unsubFuncs = [];
      };
      subscribeAll = function(newSink) {
        var input, _i, _len, _ref;
        sink = newSink;
        unsubFuncs = [];
        _ref = cloneArray(inputs);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          input = _ref[_i];
          unsubFuncs.push(input.subscribe(guardedSink(input)));
        }
        return unsubAll;
      };
      dispatcher = new Dispatcher(subscribeAll);
      subscribeThis = function(sink) {
        console.log("will subscribe " + sink);
        return dispatcher.subscribe(sink);
      };
      ReplayBus.__super__.constructor.call(this, subscribeThis);
      this.plug = function(inputStream) {
        if (ended) {
          return;
        }
        inputs.push(inputStream);
        if ((sink != null)) {
          return unsubFuncs.push(inputStream.subscribe(guardedSink(inputStream)));
        }
      };
      this.push = function(value) {
        if (sink != null) {
          return sink(next(value));
        }
      };
      this.error = function(error) {
        if (sink != null) {
          return sink(new Error(error));
        }
      };
      this.end = function() {
        ended = true;
        unsubAll();
        if (sink != null) {
          return sink(end());
        }
      };
    }

    return ReplayBus;

  })(Bacon.EventStream);

  routeStripper = /^[#\/]|\s+$/g;

  Eggs.currentLocation = (function() {
    var getFragment, getHash, hasHashChange, hasPushState, location, windowLocationStream, _ref;
    location = typeof window !== "undefined" && window !== null ? window.location : void 0;
    hasPushState = location != null ? (_ref = location.history) != null ? _ref.pushState : void 0 : void 0;
    hasHashChange = 'onhashchange' in window;
    getHash = function() {
      var match;
      match = location.href.match(/#(.*)$/);
      if (match) {
        return match[1];
      } else {
        return '';
      }
    };
    getFragment = function(fragment) {
      if (!fragment) {
        if (hasPushState || !hasHashChange) {
          fragment = location.pathname;
        } else {
          fragment = getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    };
    if (hasPushState) {
      windowLocationStream = Bacon.fromEventTarget(window, 'popstate');
    } else if (hasHashChange) {
      windowLocationStream = Bacon.fromEventTarget(window, 'hashchange');
    } else {
      windowLocationStream = Bacon.interval(100);
    }
    return windowLocationStream.map(function() {
      return getFragment();
    }).skipDuplicates().toProperty(getFragment());
  })();

  optionalParam = /\((.*?)\)/g;

  namedParam = /(\(\?)?:\w+/g;

  splatParam = /\*\w+/g;

  escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  Eggs.route = function(route) {
    if (!_.isRegExp(route)) {
      route = route.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, function(match, optional) {
        if (optional) {
          return match;
        } else {
          return '([^\/]+)';
        }
      }).replace(splatParam, '(.*?)');
      route = new RegExp('^' + route + '$');
    }
    return Eggs.currentLocation.filter(function(location) {
      return route.test(location);
    }).map(function(location) {
      return route.exec(location).slice(1);
    });
  };

}).call(this);
