// Generated by CoffeeScript 1.3.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  describe("Eggs.Model", function() {
    var emptyTestModel;
    emptyTestModel = null;
    beforeEach(function() {
      return emptyTestModel = new Eggs.Model;
    });
    it("should exists", function() {
      return expect(Eggs.Model).toBeDefined();
    });
    it("should be usable as class extension", function() {
      var TestModel, testModel;
      TestModel = (function(_super) {

        __extends(TestModel, _super);

        function TestModel() {
          return TestModel.__super__.constructor.apply(this, arguments);
        }

        return TestModel;

      })(Eggs.Model);
      testModel = new TestModel;
      return expect(testModel).not.toBeNull();
    });
    it("should initialize", function() {
      var TestModel, testModel;
      TestModel = (function(_super) {

        __extends(TestModel, _super);

        function TestModel() {
          return TestModel.__super__.constructor.apply(this, arguments);
        }

        TestModel.prototype.initialize = function() {
          return this.one = 1;
        };

        return TestModel;

      })(Eggs.Model);
      testModel = new TestModel;
      return expect(testModel.one).toEqual(1);
    });
    it("should initialize with attributes and options", function() {
      var TestModel, testModel;
      TestModel = (function(_super) {

        __extends(TestModel, _super);

        function TestModel() {
          return TestModel.__super__.constructor.apply(this, arguments);
        }

        TestModel.prototype.initialize = function(attributes, options) {
          return this.one = options.one;
        };

        return TestModel;

      })(Eggs.Model);
      testModel = new TestModel({}, {
        one: 1
      });
      return expect(testModel.one).toEqual(1);
    });
    it("should have an `attributes` method returning a Bacon.Property", function() {
      expect(_.isFunction(emptyTestModel.attributes)).toBeTruthy();
      return expect(emptyTestModel.attributes() instanceof Bacon.Property).toBeTruthy();
    });
    it("should have an `unset` method returning a Bacon.Property", function() {
      expect(_.isFunction(emptyTestModel.unset)).toBeTruthy();
      return expect(emptyTestModel.unset() instanceof Bacon.Property).toBeTruthy();
    });
    it("should have an `attributeNames` method returning a Bacon.Property", function() {
      expect(_.isFunction(emptyTestModel.attributeNames)).toBeTruthy();
      return expect(emptyTestModel.attributeNames() instanceof Bacon.Property).toBeTruthy();
    });
    it("should have an `idAttribute` property equal to 'id'", function() {
      return expect(emptyTestModel.idAttribute).toEqual('id');
    });
    it("should have an `id` method returning a Bacon.Property", function() {
      expect(_.isFunction(emptyTestModel.id)).toBeTruthy();
      return expect(emptyTestModel.id() instanceof Bacon.Property).toBeTruthy();
    });
    it("should have an `url` method returning a Bacon.Property", function() {
      expect(_.isFunction(emptyTestModel.url)).toBeTruthy();
      return expect(emptyTestModel.url() instanceof Bacon.Property).toBeTruthy();
    });
    it("should have a `fetch` method", function() {
      return expect(_.isFunction(emptyTestModel.fetch)).toBeTruthy();
    });
    it("should have a `save` method", function() {
      return expect(_.isFunction(emptyTestModel.save)).toBeTruthy();
    });
    describe("without attributes", function() {
      var TestModel, testModel;
      TestModel = (function(_super) {

        __extends(TestModel, _super);

        function TestModel() {
          return TestModel.__super__.constructor.apply(this, arguments);
        }

        return TestModel;

      })(Eggs.Model);
      testModel = null;
      beforeEach(function() {
        return testModel = new TestModel;
      });
      it("should push an empty object form `attributes()`", function() {
        return expectPropertyEvents(function() {
          return testModel.attributes().take(1);
        }, [{}]);
      });
      it("should add new attributes when setting `attributes()`", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributes().take(2);
          soon(function() {
            return testModel.attributes({
              one: 1
            });
          });
          return p;
        }, [
          {}, {
            one: 1
          }
        ]);
      });
      it("should add a new property to `attributeNames` when setting `attributes()`", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributeNames().take(2);
          soon(function() {
            return testModel.attributes({
              one: 1
            });
          });
          return p;
        }, [[], ['one']]);
      });
      return it("should push `undefined` for `id()`", function() {
        return expectPropertyEvents(function() {
          return testModel.id().take(1);
        }, [void 0]);
      });
    });
    describe("with default attributes", function() {
      var TestModel, testModel;
      TestModel = (function(_super) {

        __extends(TestModel, _super);

        function TestModel() {
          return TestModel.__super__.constructor.apply(this, arguments);
        }

        TestModel.prototype.defaults = {
          one: 'one',
          two: 'two'
        };

        return TestModel;

      })(Eggs.Model);
      testModel = null;
      beforeEach(function() {
        return testModel = new TestModel({
          two: 2
        });
      });
      it("should return Bacon.Property for each attribute in `attributes()`", function() {
        expect(testModel.attributes('one') instanceof Bacon.Property).toBeTruthy();
        return expect(testModel.attributes('two') instanceof Bacon.Property).toBeTruthy();
      });
      it("should push attributes", function() {
        return expectPropertyEvents(function() {
          return testModel.attributes().take(1);
        }, [
          {
            one: 'one',
            two: 2
          }
        ]);
      });
      it("should push single attributes", function() {
        expectPropertyEvents(function() {
          return testModel.attributes('one').take(1);
        }, ['one']);
        return expectPropertyEvents(function() {
          return testModel.attributes('two').take(1);
        }, [2]);
      });
      it("should push attributes on attributes update", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributes().take(2);
          soon(function() {
            return testModel.attributes({
              one: 1
            });
          });
          return p;
        }, [
          {
            one: 'one',
            two: 2
          }, {
            one: 1,
            two: 2
          }
        ]);
      });
      it("should push single attributes when updated", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributes('one').take(2);
          soon(function() {
            return testModel.attributes('one', 1);
          });
          return p;
        }, ['one', 1]);
      });
      it("should push attributes on single attributes update", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributes().take(2);
          soon(function() {
            return testModel.attributes('one', 1);
          });
          return p;
        }, [
          {
            one: 'one',
            two: 2
          }, {
            one: 1,
            two: 2
          }
        ]);
      });
      it("should push updated attributes from attributes set call", function() {
        return expectPropertyEvents(function() {
          return testModel.attributes({
            one: 1
          }).take(1);
        }, [
          {
            one: 1,
            two: 2
          }
        ]);
      });
      it("should push updated attributes from single attributes set call", function() {
        return expectPropertyEvents(function() {
          return testModel.attributes('one', 1).take(1);
        }, [
          {
            one: 1,
            two: 2
          }
        ]);
      });
      it("should push updated attributes from attributes unset call", function() {
        return expectPropertyEvents(function() {
          return testModel.attributes(['one'], {
            unset: true
          }).take(1);
        }, [
          {
            two: 2
          }
        ]);
      });
      it("should NOT push attributes if nothing changed", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributes().take(2);
          soon(function() {
            testModel.attributes({
              two: 2
            });
            return testModel.attributes({
              one: 1
            });
          });
          return p;
        }, [
          {
            one: 'one',
            two: 2
          }, {
            one: 1,
            two: 2
          }
        ]);
      });
      it("should NOT push a single attribute if nothing changed", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributes('one').take(2);
          soon(function() {
            testModel.attributes('one', 'one');
            return testModel.attributes('one', 1);
          });
          return p;
        }, ['one', 1]);
      });
      it("should NOT allow returned attributes object to alter the model's attributes", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributeNames().take(4).map(function(v) {
            return v.sort();
          });
          soon(function() {
            testModel.attributes().onValue(function(attr) {
              return attr.three = 3;
            });
            testModel.attributes({
              four: 4
            });
            testModel.attributes(['two'], {
              unset: true
            });
            return testModel.attributes(['one'], {
              unset: true
            });
          });
          return p;
        }, [['one', 'two'], ['four', 'one', 'two'], ['four', 'one'], ['four']]);
      });
      it("should have correct `attributeNames` names", function() {
        return expectPropertyEvents(function() {
          return testModel.attributeNames().take(1).map(function(v) {
            return v.sort();
          });
        }, [['one', 'two']]);
      });
      it("should add a new attribute", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributeNames().take(2).map(function(v) {
            return v.sort();
          });
          soon(function() {
            return testModel.attributes({
              three: 3
            });
          });
          return p;
        }, [['one', 'two'], ['one', 'three', 'two']]);
      });
      return it("should remove attributes", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributeNames().take(2).map(function(v) {
            return v.sort();
          });
          soon(function() {
            return testModel.attributes(['two', 'one'], {
              unset: true
            });
          });
          return p;
        }, [['one', 'two'], []]);
      });
    });
    describe("with validation", function() {
      var TestModel, testModel;
      TestModel = (function(_super) {

        __extends(TestModel, _super);

        function TestModel() {
          return TestModel.__super__.constructor.apply(this, arguments);
        }

        TestModel.prototype.defaults = {
          one: 'one'
        };

        TestModel.prototype.validate = function(attr) {
          if (!_.isString(attr.one)) {
            return "invalid";
          }
        };

        return TestModel;

      })(Eggs.Model);
      testModel = null;
      beforeEach(function() {
        return testModel = new TestModel;
      });
      it("should push initial attributes", function() {
        return expectPropertyEvents(function() {
          return testModel.attributes().take(1);
        }, [
          {
            one: 'one'
          }
        ]);
      });
      it("should push initial single attributes", function() {
        return expectPropertyEvents(function() {
          return testModel.attributes('one').take(1);
        }, ['one']);
      });
      it("should push an error on validation fail", function() {
        testModel.attributes().onError(function(err) {
          return expect(err).toEqual({
            error: 'invalid',
            attributes: {
              one: 1
            }
          });
        });
        return testModel.attributes({
          one: 1
        });
      });
      return it("should not validate if `shouldValidate` option is false", function() {
        testModel = new TestModel({
          one: 1
        }, {
          shouldValidate: false
        });
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributes().take(2);
          soon(function() {
            return testModel.attributes({
              one: 2
            });
          });
          return p;
        }, [
          {
            one: 1
          }, {
            one: 2
          }
        ]);
      });
    });
    describe("when invalid", function() {
      var TestModel, testModel;
      TestModel = (function(_super) {

        __extends(TestModel, _super);

        function TestModel() {
          return TestModel.__super__.constructor.apply(this, arguments);
        }

        TestModel.prototype.defaults = {
          one: 'one'
        };

        TestModel.prototype.validate = function(attr) {
          if (!_.isString(attr.one)) {
            return "invalid";
          }
        };

        return TestModel;

      })(Eggs.Model);
      testModel = null;
      beforeEach(function() {
        return testModel = new TestModel({
          one: 1
        });
      });
      it("should NOT push initial attributes if invalid", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributes().take(1);
          soon(function() {
            return testModel.attributes({
              one: 'one'
            });
          });
          return p;
        }, [
          {
            one: 'one'
          }
        ]);
      });
      it("should NOT push an initial single attributes if invalid", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributes('one').take(1);
          soon(function() {
            return testModel.attributes('one', 'one');
          });
          return p;
        }, ['one']);
      });
      return it("should NOT push initial attributeNames", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.attributeNames().take(1).map(function(v) {
            return v.sort();
          });
          soon(function() {
            return testModel.attributes({
              one: 'valid',
              two: 2
            });
          });
          return p;
        }, [['one', 'two']]);
      });
    });
    return describe("synching", function() {
      var TestModel, ajaxMock, origAjax, testModel;
      origAjax = window.$.ajax;
      ajaxMock = function(options) {
        var d;
        d = new jQuery.Deferred;
        setTimeout(function() {
          var _ref, _ref1;
          switch (options.type) {
            case 'GET':
              if (options.url.indexOf('testurl/1') >= 0) {
                console.log('GET OK');
                return d.resolve({
                  id: 1,
                  one: 1,
                  two: 2,
                  three: 'three'
                });
              } else {
                console.log('GET ERROR');
                return d.reject("ajax read error");
              }
              break;
            case 'PUT':
              if (((_ref = options.data) != null ? _ref.id : void 0) === 1) {
                console.log('PUT OK');
                return d.resolve({
                  id: 1
                });
              } else {
                console.log('PUT ERROR');
                return d.reject("ajax save error");
              }
              break;
            case 'POST':
              if (options.url.indexOf('/1') < 0 && !(((_ref1 = options.data) != null ? _ref1.id : void 0) != null)) {
                console.log('POST OK');
                return d.resolve({
                  id: 2,
                  one: 'one',
                  two: 'two'
                });
              } else {
                console.log('POST ERROR');
                return d.reject("ajax create error");
              }
              break;
            default:
              return d.reject("ajax invalid request");
          }
        }, 300);
        return d.promise();
      };
      TestModel = (function(_super) {

        __extends(TestModel, _super);

        function TestModel() {
          return TestModel.__super__.constructor.apply(this, arguments);
        }

        TestModel.prototype.defaults = {
          id: 1,
          one: 'one',
          two: 'two'
        };

        TestModel.prototype.urlRoot = 'testurl/';

        return TestModel;

      })(Eggs.Model);
      testModel = null;
      beforeEach(function() {
        window.$.ajax = ajaxMock;
        return testModel = new TestModel;
      });
      afterEach(function() {
        return window.$.ajax = origAjax;
      });
      it("should push the correct id", function() {
        return expectPropertyEvents(function() {
          return testModel.id().take(1);
        }, [1]);
      });
      it("should push the correct url", function() {
        return expectPropertyEvents(function() {
          var p;
          p = testModel.url().take(2);
          soon(function() {
            return testModel.attributes(['id'], {
              unset: true
            });
          });
          return p;
        }, ['testurl/1', 'testurl']);
      });
      it("should correctly fetch data", function() {
        return expectStreamEvents(function() {
          return testModel.fetch().take(1);
        }, [
          {
            id: 1,
            one: 1,
            two: 2,
            three: 'three'
          }
        ]);
      });
      return it("should correctly update the model on save if id is set", function() {
        return expectStreamEvents(function() {
          return testModel.save().take(1);
        }, [
          {
            id: 1,
            one: 'one',
            two: 'two'
          }
        ]);
      });
    });
  });

}).call(this);
