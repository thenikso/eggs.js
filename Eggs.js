// Generated by CoffeeScript 1.3.3
(function() {
  var Eggs, Model, escapeRegExp, namedParam, optionalParam, routeStripper, splatParam;

  Eggs = this.Eggs = {};

  Eggs.Model = Model = (function() {

    Model.prototype.idAttribute = 'id';

    Model.prototype.initialize = function() {};

    Model.prototype.parse = function(response) {
      return response;
    };

    function Model(attributes, options) {
      var attrs, attrsInitialValidationError, defaults, setAttributesBus, validAttributesBus, validAttributesProperty, validSingleAttributes,
        _this = this;
      options = _.defaults({}, options, {
        shouldValidate: true
      });
      attrs = attributes || {};
      if (defaults = _.result(this, 'defaults')) {
        attrs = _.defaults({}, attrs, defaults);
      }
      attrsInitialValidationError = options.shouldValidate && (typeof this.validate === "function" ? this.validate(_.clone(attrs)) : void 0);
      validAttributesBus = new Bacon.Bus;
      if (!attrsInitialValidationError) {
        validAttributesProperty = validAttributesBus.toProperty(_.clone(attrs));
      } else {
        validAttributesProperty = validAttributesBus.toProperty();
      }
      validSingleAttributes = {};
      validAttributesProperty.onValue(function() {});
      setAttributesBus = new Bacon.Bus;
      setAttributesBus.map(function(value) {
        return _.defaults({}, value, attrs);
      }).onValue(function(attrObject) {
        var error;
        if (_.isEqual(attrObject, attrs)) {
          return;
        }
        if (options.shouldValidate && (error = typeof _this.validate === "function" ? _this.validate(attrObject) : void 0)) {
          return validAttributesBus.error({
            error: error,
            attributes: attrObject
          });
        } else {
          attrsInitialValidationError = null;
          attrs = _.clone(attrObject);
          return validAttributesBus.push(_.clone(attrs));
        }
      });
      this.attributes = function(name, value) {
        var newAttrs, setObject;
        if (arguments.length === 0) {
          return validAttributesProperty;
        }
        if (arguments.length === 1) {
          if (_.isObject(name)) {
            setAttributesBus.push(name);
            return validAttributesProperty;
          } else if (_.has(attrs, name)) {
            if (!validAttributesProperty[name]) {
              if (!attrsInitialValidationError) {
                validAttributesProperty[name] = validAttributesBus.map("." + name).toProperty(attrs[name]);
              } else {
                validAttributesProperty[name] = validAttributesBus.map("." + name).toProperty();
              }
            }
            return validAttributesProperty[name];
          } else {
            throw "Invalid attributes accessor: " + name;
          }
        } else {
          if (_.isArray(name)) {
            if (value['unset']) {
              newAttrs = _.omit(attrs, name);
              if (_.difference(_.keys(attrs), _.keys(newAttrs))) {
                attrs = newAttrs;
                validAttributesBus.push(_.clone(attrs));
              }
              return validAttributesProperty;
            }
          } else if (_.has(attrs, name)) {
            setObject = {};
            setObject[name] = value;
            setAttributesBus.push(setObject);
            return validAttributesProperty;
          } else {
            throw "Invalid attributes update: " + name + ", " + value;
          }
        }
      };
      this.initialize.apply(this, arguments);
    }

    Model.prototype.fetch = function() {
      var _this = this;
      return this.url().take(1).flatMap(function(url) {
        return Bacon.fromPromise($.ajax({
          type: 'GET',
          dataType: 'json',
          url: url
        }));
      }).flatMap(function(result) {
        return _this.attributes(_this.parse(result));
      });
    };

    Model.prototype.save = function() {
      var _this = this;
      return Bacon.combineAsArray(this.url(), this.toJSON()).take(1).flatMap(function(info) {
        var attributes, url;
        url = info[0], attributes = info[1];
        return Bacon.fromPromise($.ajax({
          type: attributes[_this.idAttribute] ? 'PUT' : 'POST',
          dataType: 'json',
          processData: false,
          url: url,
          data: attributes
        }));
      }).flatMap(function(result) {
        return _this.attributes(_this.parse(result));
      });
    };

    Model.prototype.destroy = function() {
      return Bacon.combineAsArray(this.url(), this.id()).take(1).flatMap(function(info) {
        var id, url;
        url = info[0], id = info[1];
        if (id != null) {
          return Bacon.fromPromise($.ajax({
            type: 'DELETE',
            dataType: 'json',
            processData: false,
            url: url
          }));
        } else {
          return Bacon.once(null);
        }
      });
    };

    Model.prototype.attributeNames = function() {
      return this.attributes().map(_.keys);
    };

    Model.prototype.unset = function(attrNames) {
      if (!_.isArray(attrNames)) {
        attrNames = [attrNames];
      }
      return this.attributes(attrNames, {
        unset: true
      });
    };

    Model.prototype.id = function() {
      var _this = this;
      return this._id || (this._id = this.attributes().map(function(attr) {
        return attr[_this.idAttribute];
      }));
    };

    Model.prototype.url = function() {
      var _this = this;
      return this._url || (this._url = this.id().map(function(id) {
        var base;
        base = _.result(_this, 'urlRoot') || (function() {
          throw new Error("Expecting `urlRoot` to be defined");
        })();
        if (base.charAt(base.length - 1) === '/') {
          base = base.substring(0, base.length - 1);
        }
        if (id) {
          return "" + base + "/" + (encodeURIComponent(id));
        }
        return base;
      }));
    };

    Model.prototype.toJSON = function() {
      return this.attributes();
    };

    return Model;

  })();

  Eggs.model = function(extension) {
    var Surrogate, child, parent;
    parent = Model;
    if (extension && _.has(extension, 'constructor')) {
      child = extension.constructor;
    } else {
      child = function() {
        return parent.apply(this, arguments);
      };
    }
    Surrogate = (function() {

      function Surrogate() {
        this.constructor = child;
      }

      return Surrogate;

    })();
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;
    if (extension) {
      _.extend(child.prototype, extension);
    }
    child.__super__ = parent.prototype;
    return child;
  };

  routeStripper = /^[#\/]|\s+$/g;

  Eggs.currentLocation = (function() {
    var getFragment, getHash, hasHashChange, hasPushState, location, windowLocationStream, _ref;
    location = typeof window !== "undefined" && window !== null ? window.location : void 0;
    hasPushState = location != null ? (_ref = location.history) != null ? _ref.pushState : void 0 : void 0;
    hasHashChange = 'onhashchange' in window;
    getHash = function() {
      var match;
      match = location.href.match(/#(.*)$/);
      if (match) {
        return match[1];
      } else {
        return '';
      }
    };
    getFragment = function(fragment) {
      if (!fragment) {
        if (hasPushState || !hasHashChange) {
          fragment = location.pathname;
        } else {
          fragment = getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    };
    if (hasPushState) {
      windowLocationStream = Bacon.fromEventTarget(window, 'popstate');
    } else if (hasHashChange) {
      windowLocationStream = Bacon.fromEventTarget(window, 'hashchange');
    } else {
      windowLocationStream = Bacon.interval(100);
    }
    return windowLocationStream.map(function() {
      return getFragment();
    }).skipDuplicates().toProperty(getFragment());
  })();

  optionalParam = /\((.*?)\)/g;

  namedParam = /(\(\?)?:\w+/g;

  splatParam = /\*\w+/g;

  escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  Eggs.route = function(route) {
    if (!_.isRegExp(route)) {
      route = route.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, function(match, optional) {
        if (optional) {
          return match;
        } else {
          return '([^\/]+)';
        }
      }).replace(splatParam, '(.*?)');
      route = new RegExp('^' + route + '$');
    }
    return Eggs.currentLocation.filter(function(location) {
      return route.test(location);
    }).map(function(location) {
      return route.exec(location).slice(1);
    });
  };

}).call(this);
